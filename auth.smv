-- ACTIVITIES
-- 1. Fill in the smv definitions
-- 2. Then run this file in interactive mode to see the states
--$ NuSMV -int
--NuSMV > read_model -i uart.smv
--NuSMV > flatten_hierarchy
--NuSMV > encode_variables
--NuSMV > build_model
--NuSMV > pick_state -i
-- NuSMV > simulate -i -k 15

MODULE main
VAR
	stateA : {idle, send1, receive1, send2, receive2, send3, receive3};
	stateB : {idle, send1, receive1};
	stateS : {idle, send1, receive1};
	stateT : {idle, send1, receive1};
	--stateI : {idle, eavesdrop, remove, store, send};
	c_as_count_s : 0 .. 255;
	c_as_count_r : 0 .. 255;
	c_tgs_count_s : 0 .. 255;
	c_tgs_count_r : 0 .. 255;
	c_v_count_s : 0 .. 255;
	c_v_count_r : 0 .. 255;
	as_count_s : 0 .. 255;
	as_count_r : 0 .. 255;
	tgs_count_s : 0 .. 255;
	tgs_count_r : 0 .. 255;
	v_count_s : 0 .. 255;
	v_count_r : 0 .. 255;
ASSIGN
	init (stateA) := send1; --start by sending to S
	init (stateB) := idle;
	init (stateS) := idle;
	init (stateT) := idle;
	--init (stateI) := idle; --initial states are idle
	init (c_as_count_s) := 0;
	init (c_as_count_r) := 0;
	init (c_tgs_count_s) := 0;
	init (c_tgs_count_r) := 0;
	init (c_v_count_s) := 0;
	init (c_v_count_r) := 0;
	init (as_count_s) := 0;
	init (as_count_r) := 0;
	init (tgs_count_s) := 0;
	init (tgs_count_r) := 0;
	init (v_count_s) := 0;
	init (v_count_r) := 0;
	next (stateA) :=
		case
			stateS = send1 : send2;
			stateB = send1 : receive3;
			--stateA = receive1 : send2;
			stateT = send1 : send3;
			--stateT = receive2 : send3;
			--stateA = idle : send1;
			TRUE : idle;
		esac;
	next (stateB) :=
		case
			stateA = send3 : send1;
			--stateB = receive1 : send1;
			TRUE : idle;
		esac;
	next (stateS) :=
		case
			stateA = send1 : send1;
			--stateS = receive1 : send1;
			TRUE : idle;
		esac;
	next (stateT) :=
		case
			stateA = send2 : send1;
			--stateT = receive1 : send1;
			TRUE : idle;
		esac;
	next (v_count_s) :=
		case
			stateB = send1 & v_count_s < 254 : v_count_s + 1;
			TRUE : 0 + v_count_s;
		esac;	
	next (v_count_r) :=
		case
			stateB = send1 & v_count_r < 254 : v_count_r + 1;
			TRUE : 0 + v_count_r;   
		esac;
	next (c_v_count_s) :=
		case
			stateA = send3 & c_v_count_s < 254 : c_v_count_s + 1;
			TRUE : 0 + c_v_count_s;
		esac;
	next (c_v_count_r) :=
		case
			stateA = receive3 & c_v_count_r < 254 : c_v_count_r + 1;
			TRUE : 0 + c_v_count_r;
		esac;
	next (c_as_count_s) :=
		case
			stateA = send1 & c_as_count_s < 254 : c_as_count_s + 1;
			TRUE : 0 + c_as_count_s;
		esac;
	next (tgs_count_r) :=
		case
			stateT = send1 & tgs_count_r < 254 : tgs_count_r + 1;
			TRUE : 0 + tgs_count_r;
		esac;
	next (tgs_count_s) :=
		case
			stateT = send1 & tgs_count_s < 254 : tgs_count_s + 1;
			TRUE : 0 + tgs_count_s;
		esac;
	next (c_tgs_count_s) :=
		case
			stateA = send2 & c_tgs_count_s < 254 : c_tgs_count_s + 1;
			TRUE : 0 + c_tgs_count_s;
		esac;
	next (c_tgs_count_r) :=
		case
			stateA = send2 & c_tgs_count_r < 254 : c_tgs_count_r + 1;
			TRUE : 0 + c_tgs_count_r;
		esac;
	next (as_count_s) :=
		case
			stateS = send1 & as_count_s < 254 : as_count_s + 1;
			TRUE : 0 + as_count_s;
		esac;
	next (c_as_count_r) :=
		case
			stateA = send2 & c_as_count_r < 254 : c_as_count_r + 1;
			TRUE : 0 + c_as_count_r;
		esac;
	next (as_count_r) :=
		case
			stateS = send1 & as_count_r < 254 : as_count_r + 1;
			TRUE : 0 + as_count_r;
		esac;
SPEC AG (stateB = send1 -> c_as_count_s = as_count_r)
SPEC AG (stateA = receive3 -> as_count_s = c_as_count_r)