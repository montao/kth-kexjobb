	--A TLB has a small fixed number of slots that contain page table entries, which map virtual addresses to physical addresses. 
	-- It is typically a content-addressable memory (CAM), in which the search key is the virtual address and the search result is a physical address.

MODULE MMU (proc, pageNumber, offset)
VAR
	pagetable : array 0 .. 63 of 0..255;
	tlb : array 0 .. 7 of array 0..4 of 0..3; -- valid, virtual page, modified, protection, page frame number	

	
MODULE MEM (proc, mmu)
DEFINE
	secureAddress := 2;
	securePage := 2;
VAR
	data : array 0 .. 3 of array 0..511 of unsigned word [ 8 ]; -- main memory. 4 page frames.
	mem2proc : array 0..511 of unsigned word [ 8 ]; -- if CPU reads a page

ASSIGN		
	next (mem2proc[0]) :=
		case
			proc = read & mmu.tlb[0][1] = mmu.pageNumber : data[mmu.tlb[0][4]][0]; 
			proc = read & mmu.tlb[1][1] = mmu.pageNumber : data[mmu.tlb[1][4]][0]; 
			proc = read & mmu.tlb[2][1] = mmu.pageNumber : data[mmu.tlb[2][4]][0]; 
			proc = read & mmu.tlb[3][1] = mmu.pageNumber : data[mmu.tlb[3][4]][0]; 
			proc = read & mmu.tlb[4][1] = mmu.pageNumber : data[mmu.tlb[4][4]][0]; 
			proc = read & mmu.tlb[5][1] = mmu.pageNumber : data[mmu.tlb[5][4]][0]; 
			proc = read & mmu.tlb[6][1] = mmu.pageNumber : data[mmu.tlb[6][4]][0]; 
			proc = read & mmu.tlb[7][1] = mmu.pageNumber : data[mmu.tlb[7][4]][0]; 
			TRUE : data[0][mmu.pagetable[mmu.pageNumber]]; -- the page frame 
		esac;
	next (data[secureAddress][0]) :=
		case
			proc = write & mmu.pageNumber = securePage & mmu.offset = 0 : 0uo8_66; -- We verify this doesn't occur
			TRUE : data[secureAddress][0];
		esac;
		
MODULE CPU
VAR
	--registers : array 0 .. 16 of unsigned word [16];
	proc : {idle, read, write};

MODULE main
VAR
	pageNumber : 0 .. 63;
	offset : 0..15;
	cpu : CPU;	
	mmu : MMU (cpu.proc, pageNumber, offset);
	memory : MEM (cpu.proc, mmu);
ASSIGN
	LTLSPEC G (pageNumber != memory.securePage & offset != 0) -> G
	(memory.data[memory.secureAddress][0] = next (memory.data[memory.secureAddress][0]))	