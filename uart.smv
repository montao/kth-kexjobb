
MODULE main
-- ACTIVITIES
-- 1. Fill in the smv definitions
-- 2. Then run this file in interactive mode to see the states
--
--
--
--
--
VAR
-- system outputs
-- the model has states: idle, start, data, shift and wait
	state : {idle, start, data, shift, wait};
	send : boolean;
	load : boolean;
	busy : boolean;
	resetcounter : boolean;
	resettimer : boolean;
	count10 : 1 .. 10;
	nextbit : boolean;
ASSIGN
	init (state) := idle;
	init (send) := TRUE;
	init (nextbit) := TRUE;
	init (count10) := 1;
	init (load) := FALSE;
	init (busy) := FALSE;
	init (resetcounter) := FALSE;
	init (resettimer) := FALSE;
	next (state) :=
		case
			state = idle & send : start; -- if state is idle and load=1 then next state is start
			state = start & send : data; --if state is start then next state is data
			state = start & nextbit : shift;
			state = data & ! nextbit : data;
			state = data & nextbit : shift;
			state = shift & count10 < 10 : data;
			state = shift & count10 >= 10 : wait;
			state = wait : idle;
			TRUE : state; -- if conditions fail, then do not change state
		esac;
	next (load) :=
		case
			(state = start) & send : TRUE;
			TRUE : FALSE; -- otherwise, load is false
		esac;
	next (send) :=
		case
			(state = data) & send : TRUE;
			TRUE : FALSE; -- otherwise, send is false
		esac;
	next (count10) :=
		case
			(state = shift) & (count10 < 10) : count10 + 1;
			TRUE : count10; -- otherwise, goto waiting state
		esac;
	next (nextbit) :=
		case
			(state = shift) & (count10 < 10) : FALSE;
			TRUE : TRUE; -- otherwise, goto waiting state
		esac;
	next (busy) :=
		case
			(state = start) : TRUE;
			TRUE : TRUE; -- otherwise, goto waiting state
		esac;
	next (resetcounter) :=
		case
			(state = shift) : TRUE;
			TRUE : TRUE; -- otherwise, goto waiting state
		esac;
	next (resettimer) :=
		case
			(state = shift) : TRUE;
			TRUE : TRUE; -- otherwise, goto waiting state
		esac;		