
MODULE main
-- ACTIVITIES Jonis and Niklas
-- 1. Fill in the smv definitions
-- 2. Then run this file
VAR
-- system outputs
	Bit1 : boolean; -- Boolean variable
	Bit2 : boolean;
	state : {s1, s2, s3, s4}; -- scalar variable
	-- the model has states: location, that equals to idle, start, top, data, paritybit and tsr
	location : {idle, start, stop, data, paritybit, tsr};
	load : 0 .. 1;
IVAR
-- system inputs
	input : boolean;

ASSIGN
	init (location) := idle;
	init (state) := s1;
	init (Bit1) := FALSE;
	init (Bit2) := FALSE;
	next (location) :=
		case
			(location = idle) & (load = 1) : start; -- if state is idle and load=1 then next state is start
			(location = start) : data; --if state is start then next state is data	
			TRUE : location; -- if conditions fail, then do not change location
		esac;
	next (load) :=
		case
			(location = start) & load < 1 : load + 1;
			TRUE : load; -- otherwise, do not do anything to load
		esac;
	next (state) :=
		case
			state = s1 & input = TRUE : s2;
			state = s2 & input = FALSE : s3;
			state = s2 & input = TRUE : s4;
			state = s3 & input = FALSE : s1;
			state = s3 & input = TRUE : s2;
			state = s4 & input = FALSE : s3;
			TRUE : state; -- why?
		esac;
	next (Bit1) :=
		case
		-- To Do 
			Bit1 = FALSE : Bit2;
			TRUE : Bit2;
		esac;
	next (Bit2) :=
		case
		-- To Do 
			Bit2 = FALSE : Bit2;
			TRUE : Bit2;
		esac;
LTLSPEC G (Bit1 <-> (X Bit2))
-- the value of Bit1 now always equals the 
-- value of Bit2 in the next time step
-- This is obviously TRUE!
LTLSPEC G (Bit1 <-> (X Bit1))
-- the value of Bit1 now always equals the 
-- value of Bit1 in the next time step
-- This is obviously FALSE!
