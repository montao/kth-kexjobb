MODULE global
DEFINE
  wordlength := 16;

MODULE UART (proc, proc2UARTvalue, proc2UARTAddress, uart2CPU, uart2mem, uart2memValue)
VAR
	Rx : unsigned word [ 8 ]; -- byte from the outside
	Tx : array 0 .. 7 of unsigned word [ 8 ]; --array of bytes
	
ASSIGN
	next (Tx[0]) :=
		case
			proc = write2UART & proc2UARTAddress = 0 : proc2UARTvalue;
			TRUE : (Tx[0]);
		esac;
	next (Tx[1]) :=
		case
			proc = write2UART & proc2UARTAddress = 1 : proc2UARTvalue;
			TRUE : (Tx[1]);
		esac;
	next (Tx[2]) :=
		case		proc = write2UART & proc2UARTAddress = 2 : proc2UARTvalue;
			TRUE : (Tx[2]);
		esac;
	next (Tx[3]) :=
		case
			proc = write2UART & proc2UARTAddress = 3 : proc2UARTvalue;
			TRUE : (Tx[3]);
		esac;
	next (Tx[4]) :=
		case
			proc = write2UART & proc2UARTAddress = 4 : proc2UARTvalue;
			TRUE : (Tx[4]);
		esac;
	next (Tx[5]) :=
		case
			proc = write2UART & proc2UARTAddress = 5 : proc2UARTvalue;
			TRUE : (Tx[5]);
		esac;
	next (Tx[6]) :=
		case
			proc = write2UART & proc2UARTAddress = 6 : proc2UARTvalue;
			TRUE : (Tx[6]);
		esac;
	next (Tx[7]) :=
		case
			proc = write2UART & proc2UARTAddress = 7 : proc2UARTvalue;
			TRUE : (Tx[7]);
		esac;
	next (uart2CPU) :=
		case
			proc = read2UART : Rx;
			TRUE : Rx;
		esac;
		
-- memory model
-- the secure address is address 267 
MODULE MEM (proc, proc2memValue, proc2memAddress, mem2proc, uart2memValue)
DEFINE secureAddress := 267;

VAR
	data : array 0 .. 1023 of unsigned word [ 16 ]; -- kilobytes memory
ASSIGN
	next (mem2proc) :=
		case
			proc = read : data[proc2memAddress];
			TRUE : mem2proc;
		esac;
	next (data[secureAddress]) :=
		case
			proc = write & proc2memAddress = proc2memAddress : proc2memValue;
			TRUE : data[secureAddress];
		esac;	

MODULE main

VAR
  	global : global;
	proc : {idle, read, write, read2UART, write2UART, setDMAaddress};
	-- addresses are array indices
	proc2memAddress : 0 .. 1023;
	proc2UARTAddress : 0 .. 1023;
	-- data is array of words
	mem2proc : unsigned word [ 16 ]; 
	proc2memValue : unsigned word [ 16 ]; -- the data the CPU writes to memory
	uart2CPU : unsigned word [ 8 ]; -- the data the UART writes to the CPU
	uart2mem : unsigned word [ 8 ]; -- the data the UART writes to RAM (no DMA)
	proc2UARTvalue : unsigned word [ 8 ]; -- when the CPU writes to the UART (no DMA)
	uart2memValue : unsigned word [ 8 ]; -- external	
	
	memory : MEM (proc, proc2memValue, proc2memAddress, mem2proc, uart2mem);
	uart0 : UART (proc, proc2UARTvalue, proc2UARTAddress, uart2CPU, uart2mem, uart2memValue);
	
ASSIGN
		
	--if we write to the UART then after a while it will appear on Tx
	LTLSPEC G (proc = write2UART & proc2UARTAddress = 0) -> F ( next(uart0.Tx[0]) = proc2UARTvalue  )
	
	-- if we write to the UART but not to the secure memory, then the secure memory is constant
	LTLSPEC G (proc = write2UART & proc2memAddress != memory.secureAddress) -> G (memory.data[memory.secureAddress] = next(memory.data[memory.secureAddress]))	